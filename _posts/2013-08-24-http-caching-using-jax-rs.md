---
layout: post
header-img: img/default-blog-pic.jpg
author: anirudh.xebia
description: 
post_id: 17045
created: 2013/08/24 16:10:33
created_gmt: 2013/08/24 11:10:33
comment_status: open
---

# HTTP Caching using JAX-RS

<p>We all have noticed that opening of a webpage for the first time takes some time, but the second or third time it loads faster. This happens because whenever we visit a webpage for the first time, our browser caches the content and need not have to make a call over the network to render it.</p>
<p>This caching ability of the browser saves a lot of network bandwidth and helps in cutting down the server load.</p>
<p>Caching could happen in primarily 3 ways:</p>
<p><strong>1.) Browser or local Caches:</strong> This is the local in-memory cache of a browser. This is the fastest cache available. Whenever we hit a webpage a local copy is stored in browser and then second time it uses this local copy instead of making a real request over the network.</p>
<p><strong>2.) Proxy Caches :</strong> These are pseudo web servers that work as middlemen between browsers and websites. The difference between local and proxy cache is that the former can’t serve more than one agent, so 2 identical requests from 2 consumers behind the same network effectively hit the origin server twice: again, needless to say, proxy caches serve cached responses slower than local ones.</p>
<p><strong>3.)Gateway Caches :</strong> A gateway cache is a cache served by a proxy installed on the server side, called <em>reverse proxy</em>. It’s different from the proxy cache, in which the proxy stands into the client side: the advantage of implementing a gateway cache is that you can share the cache generated by a client with any other client of the planet doing the same request.</p>
<p>We can leverage this caching by incorporating certain mechanisms in HTTP headers and response codes (We will discuss this in detail in this blog) . And to handle this, JAX-RS provides out of the box support. Lets explore this in detail:</p>
<!--more-->

<p><strong>Expires Header</strong>
In HTTP 1.0, a simple response header called Expires would tell the browser how long it can cache an object or page. It would be a date in future after which the cache would not be valid.
So, if we made an API call to retrieve data :</p>
<p>[sourcecode]
GET /users/1
[/sourcecode]</p>
<p>The response header would be:</p>
<p>[sourcecode]
HTTP/1.1 200 OK
Content-Type: application/xml
Expires: Tue, 25 Aug 2013 16:00 GMT</p>
<hr />
<p>&lt;user id=&quot;1&quot;&gt;...&lt;/users&gt;
[/sourcecode]</p>
<p>This means the XML data is valid until 25th Aug 2013, 16:00 hours GMT.</p>
<p>JAX-RS supports this header in <strong>javax.ws.rs.core.Response</strong> object.</p>
<p>[sourcecode lang="java"]
@Path(&quot;{id}&quot;)
    @GET
    @Produces(MediaType.APPLICATION_XML)
    public Response getUserXML(@PathParam(&quot;id&quot;) Long id){
        User user = userDB.get(id);
        ResponseBuilder builder = Response.ok(user,MediaType.APPLICATION_XML);
        //Putting expires header for HTTP broswer caching.
        Calendar cal = Calendar.getInstance();
        cal.set(2013,7,25,16,0);
        builder.expires(cal.getTime());
        return builder.build();
    }
[/sourcecode]</p>
<p>But to support CDNs, proxy caches and revalidations there was a need for more enhanced headers with richer set of features, having more explicit controls. Hence in HTTP 1.1 few new headers were introduced and Expires was depricated. Lets explore them.</p>
<p><strong>Cache-Control</strong>
Cache-Control has a variable set of comma-delimited directives that define who,how and for how long it can be cached. Lets explore few of them:
-<strong>private/public</strong> : these are accessibility directives, private means a browser can cache the object but the proxies or CDNs can not and public makes it cachable by all.
<strong>-no-cache,no-store,max-age</strong> are few others where name tells the story.</p>
<p>JAX-RS provides <strong>javax.ws.rs.core.CacheControl</strong> class to represent this header.</p>
<p>[sourcecode language="java"]
@Path(&quot;{id}&quot;)
    @GET
    @Produces(MediaType.APPLICATION_XML)
    public Response getUserXMLwithCacheControl(@PathParam(&quot;id&quot;) Long id){
        User user = userDB.get(id);
        CacheControl cc = new CacheControl();
        cc.setMaxAge(300);
        cc.setNoStore(true);
        cc.setPrivate(true);
        ResponseBuilder builder = Response.ok(user,MediaType.APPLICATION_XML);
        builder.cacheControl(cc);
        return builder.build();
    }
[/sourcecode]</p>
<p><strong>Revalidation and Conditional GETs</strong> : After the cache has expired the cacher can revalidate the cache sending a request to the server to check if the cache is stale or holds good. This is done with the help of a header called as "<strong>Last-Modified</strong>".</p>
<p>[sourcecode]
HTTP/1.1 200 OK
....
Cache-Control: max-age=1000
Last-Modified: Mon, 19 aug 2013 16:00 IST
[/sourcecode]</p>
<p>To revalidate one must send a GET request with the header "<strong>If-modified-since</strong>".This is called a conditional GET, in case the data is modified a response code 200 (OK) with current value of resource will be sent. And if the data is not modified a response code of "304" is sent which would mean the cache is still valid, at this point the "Last-Modified" tag can be updated.</p>
<p><strong>Etag</strong>
Etag is another HTTP header which can be used to revalidate caches, It is usually an MD5 hash value.
A hash generated from resource is sent by server in the response as Etag value, so that while validating, client can send its Etag value to server to check if the value residing at the server matches.(As the hash is generated from resource, change in resource would generate a different hash)</p>
<p>For this conditional GET, a request with header <strong>"If-none-Match"</strong> is sent to validate.</p>
<p>[sourcecode]
GET /users/23 HTTP/1.1
If-None-Match: &quot;23432423423454654667444&quot;
[/sourcecode]</p>
<p>Also, we can have strong and weak Etag values depending on different usecases.</p>
<p>JAX-RS provides us with javax.ws.rs.core.EntityTag for the same.</p>
<p>[sourcecode lang="java"]
public class EntityTag {
.....
.....
[/sourcecode]</p>
<p>To help with conditional GETs, JAX-RS also provided one injectable helper class Request, which has methods like...</p>
<p>[sourcecode lang="java"]
....
ResponseBuilder evalutatePostConditions(EntityTag eTag);
ResponseBuilder evaluatePreConditions(Date isLastModified);
.....
[/sourcecode]</p>
<p>The etag or LastModified values sent in the request Header are compared
Lets see an example...</p>
<p>[sourcecode lang="java"]</p>
<pre><code>@Path(&amp;quot;{id}&amp;quot;)
@GET
@Produces(MediaType.APPLICATION_XML)
public Response getUserWithEtagSupport(@PathParam(&amp;quot;id&amp;quot;) Long id,
        @Context Request request){
    User user = userDB.get(id);
    //generating Etag out of hashCode of user
    EntityTag tag = new EntityTag(Integer.toString(user.hashCode()));
    CacheControl cc = new CacheControl();
    cc.setMaxAge(1000);

    ResponseBuilder builder = request.evaluatePreconditions(tag);
    if(builder!=null){
        //means the preconditions have been met and the cache is valid
        //we just need to reset the cachecontrol max age (optional)
        builder.cacheControl(cc);
        return builder.build();
    }

    //preconditions are not met and the cache is invalid
    //need to send new value with reponse code 200 (OK)
    builder = Response.ok(user,MediaType.APPLICATION_XML);
    //reset cache control and eTag (mandatory)
    builder.cacheControl(cc);
    builder.tag(tag);
    return builder.build();

}
</code></pre>
<p>[/sourcecode]</p>
<p>If the conditions have been met it returns a null which means that the latest tag and the tag provided in request header match, and there is no need to send new data with reponse OK.
"304" response meaning not-modified is send.</p>
<p>If the tags don't match up, a new RequestBuilder object is returned in which we set the new etag and the current version of data (user in this case.)</p>
<p>This is how using JAX-RS we can leverage HTTP caching to its full potential effectively.</p>