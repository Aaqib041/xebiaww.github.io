---
layout: post
header-img: img/default-blog-pic.jpg
author: sprasadjha
description: 
post_id: 8200
created: 2011/03/31 22:29:14
created_gmt: 2011/03/31 17:29:14
comment_status: open
---

# Test OAuth protected REST services using soapUI

soapUI is one of the best tools for testing the REST services. It can very efficiently help to check and ensure that the services return just what is expected. Due to these promising reasons we tried to use soapUI for testing the REST based services of our application. But we found a serious road block. The REST services in our application is secured by OAuth 1.0, and as of now soapUI has out of the box support for basic authentication only.

OAuth enables users to share their data lying with their providers with third party consumers. This is a complex use case and involves complex authentication cycles before the actual data can be accessed by consumers from the providers. Since soapUI does not provide out of box support for the authentication logic for OAuth as it does for basic authentication, we were left with two options, either create the support for OAuth authentication or use some other tool. To get around this issue we decided to add support for OAuth authorization in soapUI using the option of adding Groovy library in saopUI. I have used Soap UI 3.5.1 for evaluation.

In this blog I will explain the Groovy script required to send request to the API after the access token is already generated. The previous steps involved in the generation of access token will be dealt in my next blog post.

For OAuth 1.0, when you want to access the resource secured by OAuth the HTTP request should have following parameters for the request to get authenticated 

  1. oauth_consumer_key
  2. oauth_signature_method
  3. oauth_token
  4. oauth_version
  5. oauth_timestamp
  6. oauth_nonce
  7. oauth_signature
Please note that the first four parameters are static for a particular consumer and access token. But the last three parameters are dynamic and need to be generated before every call to the resource. We will deal each parameter one by one and see how these can be dynamically generated by using Groovy script.

**oauth_timestamp**

Please note that the time is to be in seconds**.**

** **

** **

[sourcecode language="java"] int time = (System.currentTimeMillis()/1000); String timeString = String.valueOf(time); groovyUtils.setPropertyValue("Properties", "timeString", timeString); [/sourcecode]

**oauth_nonce**

[sourcecode language="java"] long timeStampResult =Long.valueOf(timeString); String nonce =String.valueOf(timeStampResult + new Random().nextInt()); groovyUtils.setPropertyValue("Properties", "nonce", nonce); [/sourcecode]

**oauth_signature**

The generation of signature is the trickiest part. I will break the script in smaller parts and give a brief idea about the 'why' before I explain the how. This would help understand the script better. People already aware about the signature generation can jump to script.

For creating the signature you will need (i) base string, (ii) the consumer key and (iii) the access_token secret 

  * #### The Base String

This is a sample base string which is formatted for better readability.

[sourcecode language="xml"] GET&amp;http%3A%2F%2Flocalhost%3A8080%2Fabc.com6%2Frest%2Fusers%2Fget&amp;%3D %26oauth_callback%3Doob %26oauth_consumer_key%3DconsumerKey %26oauth_nonce%3D175942032 %26oauth_signature_method%3DHMAC-SHA1 %26oauth_timestamp%3D1301554858 %26oauth_token%3Df285bed1-c57c-42db-8438-3ec33fd6c4be %26oauth_version%3D1.0 %26user_name%3Ddemouser [/sourcecode]

On close inspection it is easy to understand that the base string consists of 
    * HTTP method.
    * Full path to resource.
    * All OAuth related parameters.
    * All parameters required for accessing the resource.
Please note that in the URL the parameters appear in the ascending order of the names of the parameters. And after creating a string from the above parameters the string is encoded as per the URL encoding rules.

Let us see the groovy script that gets the OAuth parameters from project level properties, and the API specific properties from the test case properties

**OAuth Specific parameters**

[sourcecode language="xml"] def oauth_version = context.expand( '${#Project#oauth_version}' ) def oauth_consumer_key = context.expand( '${#Project#oauth_consumer_key}' ) def oauth_callback = context.expand( '${#Project#oauth_callback}' ) def oauth_signature_method = context.expand( '${#Project#oauth_signature_method}' ) def oauth_token = context.expand( '${#Project#oauth_token}' ) def token_secret = context.expand( '${#Project#token_secret}' ) [/sourcecode]

**API specific parameters**

[sourcecode language="xml"] def user_name = context.expand( '${Properties#user_name}' ) [/sourcecode]

Please note that if you want to make the script generic then in that case the api specific properties and their values will have to be passed dynamically to the script.Once all the parameters are available they will have to be sorted in the alphabetic order of names of parameters, for that we will take following steps

(i) **Put the parameters in a Map**

[sourcecode language="java"] Map parameterMap = new HashMap(); parameterMap.put("oauth_version", oauth_version); parameterMap.put("oauth_consumer_key", oauth_consumer_key); ............ parameterMap.put("oauth_timestamp", timeString); parameterMap.put("user_name" , user_name); [/sourcecode]

(ii)**Sort the parameter**

[sourcecode language="java"] Map sorted = new LinkedHashMap(); List keys = new ArrayList(map.keySet()); Collections.sort(keys); for (String key : keys){ sorted.put(key, map.get(key)); } [/sourcecode]

Once the parameter are sorted, a string has to be generated in the query string format, to be appended to the encoded string generated from end point

**Create a encoded parameter string**

[sourcecode language="java"] StringBuffer encodedString = new StringBuffer(map.size() * 20); for (String key : map.keySet()) { if(encodedString.length() > 0){ encodedString.append('&'); } encodedString.append(percentEncode(key)).append('=').append(percentEncode(map.get(key))); } def encodedParamString = encodedString.toString(); [/sourcecode]

The url to the REST resource has to be encoded.

**Encode the endpoint url string **

[sourcecode language="java"] String encodedURL = URLUtils.percentEncode(endpoint); [/sourcecode]

Now create the base string using the encoded url, encoded string generated from parameters and the HTTP method.

[sourcecode language="java"] def basicString= String.format( "%s&%s&%s", "GET", encodedURL, encodedParamString ); [/sourcecode]

**Generate cryptographic function and signature**

[sourcecode language="java"] SecretKeySpec key = new SecretKeySpec(("consumerKey&"+token_secret).getBytes("UTF-8"), "HmacSHA1"); Mac mac = Mac.getInstance("HmacSHA1"); mac.init(key); byte[] bytes = mac.doFinal(basicString.getBytes("UTF-8")); def signature = new String(Base64.encodeBase64(bytes)).replace("\r\n", ""); groovyUtils.setPropertyValue("Properties", "signature", signature); [/sourcecode]

Now transfer these properties set in the testcase properties to the request parameters. That's all one needs to do to call rest based services protected by OAuth 1.0.
Reference: <http://vimeo.com/api/docs/oauth>

<https://github.com/fernandezpablo85/scribe-java>

## Comments

**[Ganesh Gembali](#5375 "2011-03-31 23:17:00"):** Hi Shankar, Nice investigation you have done there. But why you want to test your web services with authentication. While testing you can anyway disable authentication and test the service. And that too OAuth doesn't sounds to like an authorization system, so it must not have any effect on execution of your webservice. May be it is a better idea to create two profiles in your app : one with security (for releasing) and another with out security (for testing and some times development as well, as it might be irritating to authenticate everytime). As it is a third party framework it anyway doesn't make sense to test whether it is working or not. Or I may be missing some specific requirements here.

**[Shankar Jha](#5385 "2011-04-01 09:29:16"):** Hi Ganesh, You have raised a very good question. Probably you are talking about unit testing. At some point we also want to do integration testing. Please note that OAuth is a token based authentication framework. Tokens like request token, access token and keys like consumey key, consumer secret etc. While authentication all these tokens and keys are generated by our application. Some of these tokens are also persisted with expiry period etc. Now there is a substantial amount of logic and few token exchanges required before the actual resource can be accessed. This logic also needs to be tested. One point which probably needs to be understood is that OAuth only stipulates the flow but the creation of tokens and logic for invalidating them lies with the implementor. If the app is really serious about the privacy of the data they cannot but test it along with OAuth to ensure fool proof system.

**[avi](#6846 "2012-01-12 04:16:45"):** What about the second part of this post where you explain how to generate the access token? That would be appreciated a lot!

**[Sam Vo](#8747 "2012-05-10 15:47:36"):** Hi Shankar, Your topic is exactly what I'm looking for in the last couple of days. I'm new to soapUI and I wish to use soapUI to test a RESTful API with HMAC-SHA1. My problem is exactly what you described in your topic. But I still don't understand it clearly. It would be great if you can share the source code of the Groovy script and I'm looking for the second part "The generation of access token". Looking forward to hearing from you. Regards, Sam Vo

