---
layout: post
header-img: img/default-blog-pic.jpg
author: rsharma
description: 
post_id: 6112
created: 2010/11/09 11:35:11
created_gmt: 2010/11/09 06:35:11
comment_status: open
---

# Exploiting JSR 269 : How to Verify Annotations while Compiling

<h3>The Issue</h3>

<p><strong> </strong>Now-a-days every library that you use is <a href="http://download.oracle.com/javase/tutorial/java/javaOO/annotations.html">Annotations</a> based. Annotations offer a better readable approach  over the  traditional XML approach.<em><strong> But there is a problem while using  annotations, you can not force a class to have some annotations in  place.</strong></em> You can say it with XMLs by creating some abstractions but you  can not force the same with annotations, it is up to the developer to  use the required annotations. This problem orignates from the way  annotations are implemented in JDK.</p>
<p>Annotations  are basically class/method specific. With Annotations you can at best  say that if some class implements some base-class then it can have some  annotation that was used in base-class( using the <em>@<a href="http://download.oracle.com/javase/6/docs/api/java/lang/annotation/Inherited.html">inherited</a></em><a href="http://download.oracle.com/javase/6/docs/api/java/lang/annotation/Inherited.html"> </a>meta-annotation)<img title="More..." src="http://rash0208.wordpress.com/wp-includes/js/tinymce/plugins/wordpress/img/trans.gif" alt="" /><!--more--></p>
<p>[sourcecode language="java"]
@Retention(RetentionPolicy.RUNTIME)
@Inherited
public @interface MyMarkerAnnotation {}</p>
<p>@MyMarkerAnnotation
public class PlayWithAnnotation {}</p>
<p>class Playground extends PlayWithAnnotation{
// This class will contain MyMarkerAnnotation
}
[/sourcecode]</p>
<p>But  you can not say sub classes of some-other-baseclass must have  some-other-Annotation and the compiler must enforce it. There can be  varried reasons why I require this, the  following are few of them :
<ul>
    <li>I can not use the some-other-Annotation in base-class as each  sub-class must provide its own set of parameters for the  some-other-Annotation.</li>
    <li> OR  maybe the Annotation is a third-party annotation and thus I can not modify it to have @<a href="http://download.oracle.com/javase/6/docs/api/java/lang/annotation/Inherited.html">inherited </a>meta-annotation.</li>
</ul>
Keeping  the same goal in mind i.e. some how enforce sub-class to must have an  annotation, mandated by its super-class, my intention was to some how   enable the JDK compiler to break the compilation process and report the  required errors.</p>
<p>[sourcecode language="java"]
@Retention(RetentionPolicy.RUNTIME)
public @interface SecondMarkerAnnotation {}</p>
<p>public class SomeBaseClass {
}</p>
<p>public class SomeOtherSubClass extends SomeBaseClass {
}
[/sourcecode]</p>
<p>[sourcecode language="text"]
Configuration : in.annotations.playground.SomebaseClass = in.annotations.SecondMarkerAnnotation</p>
<p>Compiler Output :
error: in.annotations.playground.SomeOtherSubClass did not contain in.annotations.SecondMarkerAnnotation annotation
[/sourcecode]
<h3>First Try : Maven Plugin</h3>
In order to accomplish this I have to perform the following steps:
<ul>
    <li>somehow scan the whole project,</li>
    <li>find the sub-classes of the provided super-class,</li>
    <li>check if the sub-class contains the same annotations and then</li>
    <li>some how throw errors if it does not meet the requirements.</li>
    <li>all of this should work while making a build</li>
</ul>
At  first I thought a maven-plugin should be an apt choice for such a task  and started building the same. With this approach finding the  annotations and running with the build were the only easier parts and  rest of the steps were pretty hard ones. After a while I found out that  the approach of a maven-plugin is not an appropriate choice for such a  task esp if you want to plug into the JDK compiler.
<h3>Second Try: Using Annotation Processing API(JSR 269)</h3>
With  the advent of JSR 269 i.e. the Annotation Processing API/tool in the JDK  compiler you can already pretty much get into the JDK compilation  process. But this is something that you can do with <strong>JDK 6 ONLY</strong>. So I started using the <a href="http://download.oracle.com/javase/6/docs/api/javax/annotation/processing/AbstractProcessor.html">AbstractProcesser </a>API  provided and created my custom processor that can do the same. For each  of the steps that was required there is support from the API itself :
<table border="1" cellspacing="0" cellpadding="4" width="100%">
<tbody>
<tr valign="TOP">
<td width="50%" align="center">Steps Required</td>
<td width="50%" align="center">Support Offered</td>
</tr>
<tr valign="TOP">
<td width="50%">Scan the whole project</td>
<td width="50%">The JDK itself scans the whole project and  with the use of  @<a href="http://download.oracle.com/javase/6/docs/api/javax/annotation/processing/SupportedAnnotationTypes.html">SupportedAnnotationTypes</a>("*") the Annotation Processor API can give you every class in the project that is complied.</td>
</tr>
<tr valign="TOP">
<td width="50%">Find the required sub-classes</td>
<td width="50%">Seems like a simple Reflection stuff but the API does  not offer simple class objects with which you can work instead you have  implement the <a href="http://download.oracle.com/javase/6/docs/api/javax/lang/model/element/ElementVisitor.html">ElementVisitor </a>Api for the same.</td>
</tr>
<tr valign="TOP">
<td width="50%">Check if the class contains the same annotations</td>
<td width="50%">Once you are in the <a href="http://download.oracle.com/javase/6/docs/api/javax/lang/model/element/ElementVisitor.html">ElementVisitor </a>API this is  simple Reflection stuff. You can check the annotations of the class.</td>
</tr>
<tr valign="TOP">
<td width="50%">Throw errors if it does not meet the requirements</td>
<td width="50%">Here again the  Annotation Processor API offers the <a href="http://download.oracle.com/javase/6/docs/api/javax/annotation/processing/Messager.html">Messager </a>API that can  be used to report errors or other info. The errors when reported will break the build process.</td>
</tr>
<tr valign="TOP">
<td width="50%">Process while making a build</td>
<td width="50%">With Apt tool you can run the required the Annotation  Processors manually with the java compiler. But if you  package the Jar  file correctly i.e. having a javax.annotation.processing.Processor file  in META-INF/services folder then the compiler would automatically invoke  it every time.</td>
</tr>
</tbody>
</table>
The  only thing that is required is that you need to pass some configuration  to the implemented AnnoationProcesser. Here also the API provides full  support, you can pass arguments required for Annotation processing using  the -A options with the compiler e.g.    javac  -AannotationOption1=value1 -Aannotationoption2=value2.  Also you will be  required to put  @<a href="http://download.oracle.com/javase/6/docs/api/javax/annotation/processing/SupportedOptions.html">SupportedOptions</a>(value  = { "annoationOption1","annotationOption2"})  on your Processor else  you may get  a message that the options are not required by any  processors.</p>
<p>Using  the above mentioned APIs I created   AnnotationVerifier and made a jar  file that can be added to the classpath. You have to pass a mapping to  the AnnotationVerifier that can specify which class file will map to  which annotations. The compiler would call the verifier, that would  assert if the sub-classes contain the required annotations.</p>
<p>[sourcecode language="java"]
@SupportedAnnotationTypes(&quot;*&quot;)
@SupportedSourceVersion(SourceVersion.RELEASE_6)
@SupportedOptions(value = { &quot;AnnotationVerifier.Annotations&quot;, &quot;AnnotationVerifier.Baseclasses&quot;,
        &quot;AnnotationVerifier.ClassAnnotation.Mappings&quot; })
public class AnnotationVerifier extends AbstractProcessor {
    MessagerWrapper customMessager = new MessagerWrapper();</p>
<pre><code>@Override
public boolean process(Set&amp;lt;? extends TypeElement&amp;gt; annotations,
        RoundEnvironment roundEnv) {
    if (!roundEnv.processingOver()) {
        ConfigurationLoader configurationLoader = new AptOptionsConfigurationLoader(
                customMessager, processingEnv.getOptions());
        List&amp;lt;AnnotationBaseclassMapper&amp;gt; processOptions = configurationLoader
                .loadConfiguration();
</code></pre>