---
layout: post
header-img: img/default-blog-pic.jpg
---

# Exploiting JSR 269 : How to Verify Annotations while Compiling

### The Issue

** **Now-a-days every library that you use is [Annotations](http://download.oracle.com/javase/tutorial/java/javaOO/annotations.html) based. Annotations offer a better readable approach over the traditional XML approach._** But there is a problem while using annotations, you can not force a class to have some annotations in place.**_ You can say it with XMLs by creating some abstractions but you can not force the same with annotations, it is up to the developer to use the required annotations. This problem orignates from the way annotations are implemented in JDK. Annotations are basically class/method specific. With Annotations you can at best say that if some class implements some base-class then it can have some annotation that was used in base-class( using the _@[inherited](http://download.oracle.com/javase/6/docs/api/java/lang/annotation/Inherited.html)_[ ](http://download.oracle.com/javase/6/docs/api/java/lang/annotation/Inherited.html)meta-annotation)![](http://rash0208.wordpress.com/wp-includes/js/tinymce/plugins/wordpress/img/trans.gif) [sourcecode language="java"] @Retention(RetentionPolicy.RUNTIME) @Inherited public @interface MyMarkerAnnotation {} @MyMarkerAnnotation public class PlayWithAnnotation {} class Playground extends PlayWithAnnotation{ // This class will contain MyMarkerAnnotation } [/sourcecode] But you can not say sub classes of some-other-baseclass must have some-other-Annotation and the compiler must enforce it. There can be varried reasons why I require this, the  following are few of them : 

  * I can not use the some-other-Annotation in base-class as each sub-class must provide its own set of parameters for the some-other-Annotation.
  * OR  maybe the Annotation is a third-party annotation and thus I can not modify it to have @[inherited ](http://download.oracle.com/javase/6/docs/api/java/lang/annotation/Inherited.html)meta-annotation.
Keeping the same goal in mind i.e. some how enforce sub-class to must have an annotation, mandated by its super-class, my intention was to some how enable the JDK compiler to break the compilation process and report the required errors. [sourcecode language="java"] @Retention(RetentionPolicy.RUNTIME) public @interface SecondMarkerAnnotation {} public class SomeBaseClass { } public class SomeOtherSubClass extends SomeBaseClass { } [/sourcecode] [sourcecode language="text"] Configuration : in.annotations.playground.SomebaseClass = in.annotations.SecondMarkerAnnotation Compiler Output : error: in.annotations.playground.SomeOtherSubClass did not contain in.annotations.SecondMarkerAnnotation annotation [/sourcecode] 

### First Try : Maven Plugin

In order to accomplish this I have to perform the following steps: 

  * somehow scan the whole project,
  * find the sub-classes of the provided super-class,
  * check if the sub-class contains the same annotations and then
  * some how throw errors if it does not meet the requirements.
  * all of this should work while making a build
At first I thought a maven-plugin should be an apt choice for such a task and started building the same. With this approach finding the annotations and running with the build were the only easier parts and rest of the steps were pretty hard ones. After a while I found out that the approach of a maven-plugin is not an appropriate choice for such a task esp if you want to plug into the JDK compiler. 

### Second Try: Using Annotation Processing API(JSR 269)

With the advent of JSR 269 i.e. the Annotation Processing API/tool in the JDK compiler you can already pretty much get into the JDK compilation process. But this is something that you can do with **JDK 6 ONLY**. So I started using the [AbstractProcesser ](http://download.oracle.com/javase/6/docs/api/javax/annotation/processing/AbstractProcessor.html)API provided and created my custom processor that can do the same. For each of the steps that was required there is support from the API itself : 

Steps Required
Support Offered

Scan the whole project
The JDK itself scans the whole project and with the use of @[SupportedAnnotationTypes](http://download.oracle.com/javase/6/docs/api/javax/annotation/processing/SupportedAnnotationTypes.html)("*") the Annotation Processor API can give you every class in the project that is complied.

Find the required sub-classes
Seems like a simple Reflection stuff but the API does not offer simple class objects with which you can work instead you have implement the [ElementVisitor ](http://download.oracle.com/javase/6/docs/api/javax/lang/model/element/ElementVisitor.html)Api for the same.

Check if the class contains the same annotations
Once you are in the [ElementVisitor ](http://download.oracle.com/javase/6/docs/api/javax/lang/model/element/ElementVisitor.html)API this is simple Reflection stuff. You can check the annotations of the class.

Throw errors if it does not meet the requirements
Here again the Annotation Processor API offers the [Messager ](http://download.oracle.com/javase/6/docs/api/javax/annotation/processing/Messager.html)API that can be used to report errors or other info. The errors when reported will break the build process.

Process while making a build
With Apt tool you can run the required the Annotation Processors manually with the java compiler. But if you package the Jar file correctly i.e. having a javax.annotation.processing.Processor file in META-INF/services folder then the compiler would automatically invoke it every time.
The only thing that is required is that you need to pass some configuration to the implemented AnnoationProcesser. Here also the API provides full support, you can pass arguments required for Annotation processing using the -A options with the compiler e.g.    javac -AannotationOption1=value1 -Aannotationoption2=value2.  Also you will be required to put  @[SupportedOptions](http://download.oracle.com/javase/6/docs/api/javax/annotation/processing/SupportedOptions.html)(value = { "annoationOption1","annotationOption2"})  on your Processor else you may get a message that the options are not required by any processors. Using the above mentioned APIs I created AnnotationVerifier and made a jar file that can be added to the classpath. You have to pass a mapping to the AnnotationVerifier that can specify which class file will map to which annotations. The compiler would call the verifier, that would assert if the sub-classes contain the required annotations. [sourcecode language="java"] @SupportedAnnotationTypes("*") @SupportedSourceVersion(SourceVersion.RELEASE_6) @SupportedOptions(value = { "AnnotationVerifier.Annotations", "AnnotationVerifier.Baseclasses", "AnnotationVerifier.ClassAnnotation.Mappings" }) public class AnnotationVerifier extends AbstractProcessor { MessagerWrapper customMessager = new MessagerWrapper(); @Override public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) { if (!roundEnv.processingOver()) { ConfigurationLoader configurationLoader = new AptOptionsConfigurationLoader( customMessager, processingEnv.getOptions()); List<AnnotationBaseclassMapper> processOptions = configurationLoader .loadConfiguration();